from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import List, Optional, Dict, Any


class Action(Enum):
    LONG = "LONG"
    SHORT = "SHORT"
    FLAT = "FLAT"


@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    action: Action
    confidence: float  # 0 to 1
    reason: str
    indicators: Dict[str, Any]


class BaseStrategy(ABC):
    """Base class for all trading strategies."""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.strategy_params = config.get('strategy_params', {})
        self.signal_stack = config.get('signal_stack', {})
        self.risk_params = config.get('risk_params', {})
    
    @abstractmethod
    def generate_signal(self, prices: List[float], current_position: Action) -> Signal:
        """
        Generate a trading signal based on price history.
        
        Args:
            prices: Historical price series (oldest to newest)
            current_position: Current position (LONG, SHORT, or FLAT)
        
        Returns:
            Signal object with action, confidence, and reasoning
        """
        pass
    
    def apply_signal_filters(self, signal: Signal, indicators: Dict[str, Any]) -> Signal:
        """Apply additional signal filters from signal_stack config."""
        confidence = signal.confidence
        
        # RSI filter
        if self.signal_stack.get('use_rsi', False):
            rsi = indicators.get('rsi')
            if rsi is not None:
                overbought = self.signal_stack.get('rsi_overbought', 70)
                oversold = self.signal_stack.get('rsi_oversold', 30)
                
                # Reduce confidence if RSI contradicts the signal
                if signal.action == Action.LONG and rsi > overbought:
                    confidence *= 0.5
                elif signal.action == Action.SHORT and rsi < oversold:
                    confidence *= 0.5
        
        # Volatility filter
        if self.signal_stack.get('use_volatility_filter', False):
            vol = indicators.get('volatility')
            if vol is not None:
                threshold = self.signal_stack.get('volatility_threshold', 1.5)
                # High volatility reduces confidence
                if vol > threshold * 0.02:  # Compare to base volatility
                    confidence *= 0.7
        
        return Signal(
            action=signal.action,
            confidence=confidence,
            reason=signal.reason,
            indicators=indicators
        )
    
    def get_position_size(self, equity: float, price: float) -> float:
        """Calculate position size based on risk parameters."""
        position_pct = self.risk_params.get('position_size_pct', 10) / 100
        max_leverage = self.risk_params.get('max_leverage', 1.0)
        
        # Calculate base position size
        position_value = equity * position_pct * max_leverage
        shares = position_value / price
        
        return shares
